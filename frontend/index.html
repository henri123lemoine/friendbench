<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FriendBench™ - LLM Benchmark</title>
  <meta name="description" content="A simple visualization of the FriendBench AI model scores">
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f8f9fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      max-width: 880px;
      width: 100%;
      margin: 0 auto;
      text-align: center;
    }
    h1 { margin-bottom: 0.5em; }
    p { margin-bottom: 2em; }
    @media (max-width: 600px) {
      body { padding: 10px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>FriendBench™</h1>
    <div id="chart-container"></div>
  </div>

  <script src="data.js"></script>
  <script>
    // Sort models by score in descending order
    const sortedData = [...modelData].sort((a, b) => b.score - a.score);

    // Color interpolation helper functions
    const hexToRgb = hex => {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    };

    const rgbToHex = ({r, g, b}) =>
      '#' + [r, g, b].map(x => Math.round(x).toString(16).padStart(2, '0')).join('');

    const interpolateColor = (color1, color2, factor) => {
      const c1 = hexToRgb(color1);
      const c2 = hexToRgb(color2);
      return {
        r: c1.r + (c2.r - c1.r) * factor,
        g: c1.g + (c2.g - c1.g) * factor,
        b: c1.b + (c2.b - c1.b) * factor
      };
    };

    // Generate colors for any number of points
    const getColor = (index, total) => {
      // Define base colors for gradient
      const baseColors = ['#9370DB', '#1E90FF', '#3CB371'];

      if (total === 1) return baseColors[0];

      // Calculate which segment of the gradient we're in
      const segments = baseColors.length - 1;
      const segment = (index / (total - 1)) * segments;
      const segmentIndex = Math.floor(segment);
      const segmentFactor = segment - segmentIndex;

      // If we're exactly on a base color, return it
      if (segmentFactor === 0 && baseColors[segmentIndex]) {
        return baseColors[segmentIndex];
      }

      // Otherwise interpolate between the two nearest base colors
      return rgbToHex(
        interpolateColor(
          baseColors[segmentIndex],
          baseColors[segmentIndex + 1],
          segmentFactor
        )
      );
    };

    // Minimal chart generator
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("viewBox", "0 0 880 500");
    svg.setAttribute("width", "100%");
    svg.setAttribute("height", "100%");

    // Background
    svg.innerHTML = `
      <rect width="880" height="500" fill="#f8f9fa"/>

      <!-- Axes -->
      <line x1="100" y1="100" x2="100" y2="400" stroke="#333" stroke-width="2"/>
      <line x1="100" y1="400" x2="780" y2="400" stroke="#333" stroke-width="2"/>

      <!-- Y-axis ticks and labels -->
      ${[0, 25, 50, 75, 100].map(tick => `
        <line x1="95" y1="${400 - tick * 3}" x2="100" y2="${400 - tick * 3}" stroke="#333" stroke-width="2"/>
        <text x="90" y="${405 - tick * 3}" font-family="Arial" font-size="12" text-anchor="end" fill="#666">${tick}</text>
      `).join('')}

      <!-- Y-axis label -->
      <text x="55" y="250" font-family="Arial" font-size="14" font-weight="bold" text-anchor="middle"
        fill="#666" transform="rotate(-90, 55, 250)">Friend Score</text>
    `;

    // Calculate bar spacing based on number of models
    const totalModels = sortedData.length;
    const availableWidth = 680; // 780 - 100 (right margin)
    const barWidth = Math.min(60, (availableWidth / totalModels) - 20);
    const spacing = (availableWidth - (barWidth * totalModels)) / (totalModels - 1);

    // Generate bars and labels
    sortedData.forEach((model, i) => {
      const x = 100 + (i * (barWidth + spacing));
      const height = model.score * 3;
      const y = 400 - height;
      const color = getColor(i, totalModels);

      svg.innerHTML += `
        <rect x="${x}" y="${y}" width="${barWidth}" height="${height}"
          fill="${color}" opacity="0.8" rx="5"/>
        <text x="${x + barWidth/2}" y="430" font-family="Arial" font-size="12"
          text-anchor="middle" fill="#333">${model.name}</text>
        <text x="${x + barWidth/2}" y="${y - 10}" font-family="Arial" font-size="14"
          font-weight="bold" text-anchor="middle" fill="#333">${model.score}</text>
      `;
    });

    // Copyright
    svg.innerHTML += `
      <text x="440" y="470" font-family="Arial" font-size="12"
        text-anchor="middle" fill="#999">© High Taste Testers 2025</text>
    `;

    document.getElementById('chart-container').appendChild(svg);
  </script>
</body>
</html>
